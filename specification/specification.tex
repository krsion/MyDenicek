\documentclass{article}

\usepackage[a-2u]{pdfx}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage[ddmmyyyy]{datetime}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, positioning, fit, backgrounds}

\renewcommand{\dateseparator}{.}
\renewcommand{\baselinestretch}{1.5}
\geometry{margin=2cm}

\def\ResearchProject{Research project}
\def\CompanyProject{Company project}
\def\SoftwareProject{Software project}

% METADATA SECTION START
\def\StudentsFullName{Bc. Ondřej Krsička}
\def\Obor{Computer Science - Software and Data Engineering}
\def\ProjetTitle{Using CRDTs to enable collaborative editing in Denicek}
\def\ProjectType{\ResearchProject}
\def\SupervisorFullName{Mgr. Tomáš Petříček, Ph.D.}
\def\ExpectedStart{1.9.2025}
\def\ExpectedEnd{31.3.2026}
% METADATA SECTION END

\title{\ProjetTitle}
\author{\StudentsFullName}

\begin{document}

\centerline{\Large \textbf{Specification of team software project}}
\centerline{ \textbf{Department of Software Engineering}}
\centerline{ \textbf{Faculty of Mathematics and Physics, Charles University}}
\bigskip
{\noindent\begin{tabular*}{\textwidth}{ >{\raggedleft}m{4cm} l}
 {\bf Solvers:} & \StudentsFullName \\
 {\bf Study program:} & \Obor \\
 & \\
 {\bf Project title:} & \ProjetTitle \\
 {\bf Project type:} & \ProjectType \\
 & \\
 {\bf Supervisor:} & \SupervisorFullName \\
 & \\
 {\bf Expected start:} & \ExpectedStart \\
 {\bf Expected end:} & \ExpectedEnd \\
\end{tabular*}}


\section{Introduction}

\emph{MyDenicek} is a CRDT-based local-first document editing substrate that enables collaborative editing of tree-structured documents with automatic conflict resolution. The project reimplements the synchronization layer of the original \emph{Denicek} system~\cite{denicek2024}, replacing Operational Transformation (OT) with Conflict-free Replicated Data Types (CRDTs) to satisfy the requirements of local-first software~\cite{klep2019}.

The original \emph{Denicek} system provides end-user programming experiences including collaborative editing, programming by demonstration (recording and replaying user actions), incremental recomputation, and schema change control. However, its OT-based synchronization is complex, error-prone, and requires a central server. This project creates an alternative built on CRDTs that enables true peer-to-peer collaboration without a central authority.

\emph{MyWebnicek} is a web-based programming system built on top of \emph{MyDenicek}, providing a user interface for document navigation, editing, and collaborative features. It demonstrates the end-user programming capabilities through formative examples such as counter apps, todo lists, and document refactoring scenarios. The application is deployed at \url{https://krsion.github.io/MyDenicek/} with real-time collaboration enabled via a WebSocket sync server hosted on Azure App Service.

The project is inspired by \emph{MyWebstrates}~\cite{klokmose2024}, a local-first CRDT-based alternative to Webstrates. Both \emph{MyDenicek} (the core library) and \emph{MyWebnicek} (the web application) are implemented in TypeScript.

\subsection{Relation to Denicek}

This project directly extends the research presented at \emph{ACM UIST 2025}~\cite{denicek2024}. While the original Denicek uses Operational Transformation for synchronization, MyDenicek replaces this with a CRDT-based approach using Loro~\cite{loro}. Loro provides a native movable tree CRDT (LoroTree) that handles concurrent structural edits, node moves, and reparenting automatically. The key architectural difference is that nodes are indexed by unique IDs rather than paths, avoiding the ``shifting index'' problem that occurs during concurrent structural edits.

The project maintains a clear separation between the CRDT substrate (\texttt{@mydenicek/core}) and the user interface (\texttt{mywebnicek}), enabling future development of alternative front-ends similar to how the original Denicek supports both Webnicek and Datnicek.


\section{Project description}

The project consists of two main components: the core CRDT library (\emph{MyDenicek}) and the web application (\emph{MyWebnicek}). The core library provides a TypeScript API for document manipulation with automatic conflict resolution, while the web application provides a user interface for end-user programming experiences.

\subsection{User journey}

The user journey through MyWebnicek consists of the following phases:

\begin{enumerate}
\item \textbf{Document Creation/Loading:} Users can create a new document or load an existing one. Documents can be shared via URL for collaborative editing.

\item \textbf{Document Navigation:} Users navigate the document tree using keyboard shortcuts or mouse clicks. The selected node is highlighted in both the rendered view and the JSON inspector.

\item \textbf{Document Editing:} Users perform edit operations through toolbar controls. Operations include adding nodes, editing values, moving nodes, and deleting nodes.

\item \textbf{Recording/Replay:} Users can record a sequence of edit operations and replay them on different parts of the document, enabling programming by demonstration.

\item \textbf{Collaboration:} Multiple users can edit the same document simultaneously. Changes are synchronized via WebSocket and merged automatically using CRDTs.

\item \textbf{Undo/Redo:} Users can undo and redo operations. The undo history is local to each user.
\end{enumerate}


\subsection{Functional requirements}

The following functional requirements specify the capabilities of the system. Requirements labeled [Core] relate to the \texttt{@mydenicek/core} library, while [Web] requirements relate to the \texttt{mywebnicek} application.

\subsubsection{Core Library Requirements}

\textbf{FR-01: Document Representation} [Core] The system shall represent documents as trees of nodes, where each node has a unique ID, a kind (element, value, formula, ref, or action), and additional properties based on its kind.

\textbf{FR-02: Element Nodes} [Core] Element nodes shall have a tag name, a dictionary of attributes, and an ordered list of child node IDs.

\textbf{FR-03: Value Nodes} [Core] Value nodes shall contain a text string stored internally as a \texttt{LoroText} CRDT container, enabling character-level collaborative editing through splice operations.

\textbf{FR-04: Node Operations} [Core] The system shall support the following operations on nodes:
\begin{itemize}
\setlength{\itemsep}{-5pt}
\item \texttt{addChild}: Add a new child node (element, value, formula, ref, or action) to a parent
\item \texttt{deleteNode}: Remove a node and its descendants from the document
\item \texttt{moveNode}: Move a node to a different parent or position
\item \texttt{copyNode}: Create a copy of a node under a target parent
\item \texttt{updateTag}: Change the tag name of an element node
\item \texttt{updateAttribute}: Set or modify an attribute on an element node
\item \texttt{spliceValue}: Insert, delete, or replace text within a value node
\end{itemize}

\textbf{FR-05: Conflict Resolution} [Core] The system shall automatically resolve conflicts when concurrent operations are applied:
\begin{itemize}
\setlength{\itemsep}{-5pt}
\item Concurrent move operations on the same node shall result in the node appearing in one location (determined by Loro's tree CRDT semantics)
\item Concurrent attribute updates shall use Last-Writer-Wins (LWW) semantics
\item Concurrent child additions shall preserve both children
\item Concurrent tag updates shall use LWW semantics
\end{itemize}

\textbf{FR-06: Undo/Redo} [Core] The system shall maintain an undo stack and redo stack for each local session. Undo shall reverse the most recent local operation, and redo shall reapply the most recently undone operation.

\textbf{FR-07: Recording} [Core] The system shall automatically record all local document mutations by subscribing to Loro's event system. Each local event carries diffs that are accumulated and converted to generalized patches with concrete node IDs. Variable placeholders (\texttt{\$0}, \texttt{\$1}, etc.) are assigned only when storing actions in a button or at replay time, not in the recorded history.

\textbf{FR-08: Replay} [Core] The system shall support replaying a recorded script starting from a specified node. The generalized node IDs in the script shall be bound to actual node IDs based on the starting node.

\textbf{FR-09: Formula Nodes} [Core] Formula nodes compute values from an \texttt{operation} and child arguments (value nodes, ref nodes, or nested formulas). Evaluation detects circular references and enforces max recursion depth.

\textbf{FR-10: Formula Operations} [Core] Built-in operations: string (\texttt{concat}, \texttt{uppercase}, etc.), math (\texttt{sum}, \texttt{product}, etc.), and tree (\texttt{countChildren}).

\textbf{FR-11: Ref Nodes} [Core] Ref nodes reference other nodes via a \texttt{target} ID. In formulas, they resolve to the target's value.

\textbf{FR-12: Action Nodes} [Core] Action nodes store recorded operations as generalized patches. They have a \texttt{label}, \texttt{target} (bound to \texttt{\$0}), and \texttt{actions} list. Triggering replays patches on the target.

\subsubsection{Web Application Requirements}

\textbf{FR-13: Document Rendering} [Web] The application shall render the document tree as HTML, allowing users to see the final document appearance.

\textbf{FR-14: Node Selection} [Web] Users shall be able to select nodes by clicking on them in the rendered view or navigating with keyboard shortcuts (arrow keys, Tab).

\textbf{FR-15: JSON Inspector} [Web] The application shall display a JSON view of the document structure, highlighting the currently selected node.

\textbf{FR-16: Element Details Panel} [Web] When an element node is selected, the application shall display its tag, attributes, and available operations.

\textbf{FR-17: Add Node Interface} [Web] Users shall be able to add child nodes through a popover interface that allows specifying the tag name or text content.

\textbf{FR-18: Recording Controls} [Web] The application shall provide controls to start and stop recording, and display the recorded script.

\textbf{FR-19: Replay Controls} [Web] The application shall provide controls to replay a recorded script on the currently selected node.

\textbf{FR-20: Keyboard Shortcuts} [Web] The application shall support keyboard shortcuts for common operations:
\begin{itemize}
\setlength{\itemsep}{-5pt}
\item Arrow keys: Navigate between nodes
\item Delete/Backspace: Delete selected node
\item Ctrl+Z: Undo
\item Ctrl+Y / Ctrl+Shift+Z: Redo
\end{itemize}

\textbf{FR-21: WebSocket Synchronization} [Web] The application shall synchronize document changes with other clients via WebSocket connection to a sync server.

\textbf{FR-22: Formula Rendering} [Web] Formula nodes display computed results or formula structure (for debugging).

\textbf{FR-23: Action Node Rendering} [Web] Action nodes render as buttons; clicking triggers replay on the target.


\subsection{Non-functional requirements}

The following non-functional requirements specify quality attributes and system constraints.

\textbf{NFR-01: Convergence} All replicas of a document shall eventually converge to the same state after receiving all operations, regardless of the order in which operations are received.

\textbf{NFR-02: Offline Support} The system shall support offline editing. Local changes shall be preserved and synchronized when connectivity is restored.

\textbf{NFR-03: Response Time} User interface operations (node selection, editing) shall complete within 100ms to provide responsive feedback.

\textbf{NFR-04: Browser Compatibility} The web application shall function correctly on current versions of Chrome, Firefox, Safari, and Edge.

\textbf{NFR-05: Type Safety} The codebase shall use TypeScript with strict type checking. The use of \texttt{any} type is prohibited; \texttt{unknown} or specific types shall be used instead.

\textbf{NFR-06: Code Quality} The codebase shall pass ESLint checks with no errors. Unused imports shall be removed automatically, and imports shall be sorted consistently.

\textbf{NFR-07: Test Coverage} Core library functionality shall be covered by unit tests (Vitest). User interface functionality shall be covered by end-to-end tests (Playwright).

\textbf{NFR-08: Documentation} Public APIs shall be documented with JSDoc comments. The README shall contain setup instructions and usage examples.

\textbf{NFR-09: Reproducibility} The development environment shall be reproducible using npm. All dependencies shall be specified in package.json with locked versions.

\textbf{NFR-10: Deployment} The web application shall be deployed to GitHub Pages at \url{https://krsion.github.io/MyDenicek/}. The sync server shall be deployed to Azure App Service at \url{wss://mydenicek-sync-prod.azurewebsites.net}, enabling real-time collaboration between users.


\subsection{Architecture}

The system follows a monorepo structure with clear separation between packages:

\begin{verbatim}
apps/
  mywebnicek/               # React 19 + Fluent UI web application
  mydenicek-sync-server/    # WebSocket sync server
packages/
  mydenicek-core/           # Core CRDT logic (Loro wrapper)
  mydenicek-react/          # React hooks and context
\end{verbatim}

\subsubsection{Core Library Architecture}

The core library (\texttt{@mydenicek/core}) follows a ``deep module'' design where \textbf{DenicekDocument} is the single entry point, hiding all Loro CRDT complexity behind a simple API:

\begin{itemize}
\setlength{\itemsep}{-5pt}
\item Read: \texttt{getNode()}, \texttt{getParentId()}, \texttt{getChildIds()}, \texttt{getRootId()}
\item Write: \texttt{addChild()}, \texttt{deleteNode()}, \texttt{moveNode()}, \texttt{copyNode()}, \texttt{updateAttribute()}, \texttt{updateTag()}, \texttt{spliceValue()}, \texttt{updateFormulaOperation()}, \texttt{updateRefTarget()}
\item Undo/Redo: \texttt{undo()}, \texttt{redo()}, \texttt{canUndo}, \texttt{canRedo}
\item Recording: \texttt{replay(script, startNodeId)}, \texttt{getHistory()}, \texttt{clearHistory()}
\item Sync: \texttt{connectToSync()}, \texttt{disconnectSync()}
\item Serialization: \texttt{export()}, \texttt{import()}
\end{itemize}

Each mutation method commits automatically, and Loro's undo manager groups rapid commits (within 1000ms) for natural undo behavior. No Loro types are exposed in the public API.

\subsubsection{Data Flow}

\begin{enumerate}
\item User performs an action in the UI (e.g., clicks ``Add Child'')
\item React component calls \texttt{document.addChild(parentId, \{ ... \})}
\item DenicekDocument applies the change to the Loro document and commits
\item Loro generates patches; undo manager captures inverse
\item The document's event subscription captures per-event diffs for the history view
\item Loro synchronizes changes to connected peers via WebSocket
\item Remote peers receive patches and update their local document
\item React re-renders based on the updated document state
\end{enumerate}


\subsection{Formula Engine}

The formula engine enables spreadsheet-like reactive computation. Nodes derive values from other nodes through operations.

\subsubsection{Node Types}

\textbf{Formula Nodes} compute values. They have an \texttt{operation} attribute (e.g., ``sum'') and children serving as arguments.

\textbf{Ref Nodes} reference other nodes via a \texttt{target} attribute. In formulas, they resolve to the target's value.

\textbf{Value Nodes} provide literal arguments.

\subsubsection{Evaluation}

The evaluator traverses the formula tree recursively:
\begin{enumerate}
\item Check recursion depth (max 100) and circular references
\item Evaluate each child: value nodes yield literals, ref nodes resolve targets, formula nodes recurse
\item Look up operation, validate arity, invoke with arguments
\item Return result or error (\texttt{\#ERR:} prefix)
\end{enumerate}

\subsubsection{Built-in Operations}

\textbf{String:} \texttt{lowerText}, \texttt{upperText}, \texttt{capitalize}, \texttt{concat} (variadic), \texttt{trim}, \texttt{length}, \texttt{replace}

\textbf{Math:} \texttt{sum}, \texttt{product}, \texttt{mod}, \texttt{round}, \texttt{floor}, \texttt{ceil}, \texttt{abs}

\textbf{Tree:} \texttt{countChildren}

\subsubsection{Errors}

\begin{itemize}
\setlength{\itemsep}{-5pt}
\item \texttt{\#ERR: max depth exceeded}
\item \texttt{\#ERR: circular reference}
\item \texttt{\#ERR: node deleted}
\item \texttt{\#ERR: \{op\} not found}
\item \texttt{\#ERR: \{op\} expects \{X\} args, got \{Y\}}
\item \texttt{\#ERR: \{op\} requires number} (type coercion failed)
\end{itemize}

\subsubsection{Example}

Nested formulas compute a formatted name. Given value nodes \texttt{"john"} and \texttt{"doe"}, the formula \texttt{concat(capitalize(ref->john), " ", capitalize(ref->doe))} evaluates to \texttt{"John Doe"}.


\subsection{Programmable Buttons (Action Nodes)}

Action nodes enable programming by demonstration: users record operations and save them to a button for replay.

\subsubsection{Structure}

An action node stores: \texttt{label} (display text), \texttt{target} (node bound to \texttt{\$0}), and \texttt{actions} (list of \texttt{GeneralizedPatch} objects).

\subsubsection{Generalized Patches}

Raw Loro diffs reference concrete container and tree IDs, tying them to a specific document state. Generalized patches introduce two abstractions on top of Loro diffs that make them portable and replayable: (1)~variable placeholders (\texttt{\$0}, \texttt{\$1}, ...) can replace concrete node IDs so the same script can be replayed on different target nodes, and (2)~create patches distinguish copies (\texttt{sourceId}) from direct creates (\texttt{data}) so replay knows whether to call \texttt{copyNode} or \texttt{addChildren}.

The recording history stores patches with concrete node IDs, which are displayed as clickable references in the UI. Variable placeholders are only used in stored button scripts (action nodes) and are assigned automatically when the user saves recorded actions to a button or triggers replay. There are three patch types:

\begin{verbatim}
TreePatch {
    type: "tree"
    action: "create" | "delete" | "move"
    target: string          // $0, $1, ... or node ID
    parent?: string         // parent node variable/ID
    index?: number          // position among siblings
    sourceId?: string       // source node for copies
    data?: PatchNodeData    // inline node template for creates
}

MapPatch {
    type: "map"
    target: string          // node variable/ID
    key: string             // "tag", "attrs", etc.
    value: unknown
}

TextPatch {
    type: "text"
    target: string          // node variable/ID
    index: number
    delete: number
    insert: string
}
\end{verbatim}

Variables (used in button scripts and replay only): \texttt{\$0} is the target node; \texttt{\$1}, \texttt{\$2}, ... are nodes created during replay.

\subsubsection{Recording}

Recording is automatic---the \texttt{DenicekDocument} subscribes to Loro's event system and accumulates per-event diffs for all local mutations. These diffs are converted to generalized patches on demand:
\begin{enumerate}
\item Perform operations (add, edit, delete, move nodes)
\item Loro fires events; the subscriber captures the diffs carried by each event
\item \texttt{getHistory()} converts accumulated diffs to generalized patches with concrete node IDs, suppressing redundant map/text patches for same-event node creates
\item The UI displays patches with clickable node IDs; users can retarget any ID to a different node and select a subset of actions
\item Click ``Apply'' to replay on the selected node, or ``Add to Button'' to store in an action node---at this point, concrete IDs are generalized to variable placeholders (\texttt{\$0}, \texttt{\$1}, ...) automatically
\end{enumerate}

\subsubsection{Replay}

\begin{enumerate}
\item Click button or use replay controls
\item System maps \texttt{\$0} to target node
\item For each patch: substitute variables, apply patch, assign new variables to created nodes
\end{enumerate}

\subsubsection{Rendering}

Action nodes render as buttons. Click triggers replay; Ctrl+click selects for editing.


\subsection{Formative Examples}

These examples from the original Denicek paper demonstrate the end-user programming model.

\subsubsection{Counter}

Demonstrates formulas and action buttons. The document contains a \texttt{formula(sum)} node displaying the current count and two action buttons (``Increment'' and ``Decrement'').

To create the increment button: the user adds a value node \texttt{"1"} as a child of the sum formula and records this step. The recorded action is programmed to the ``Increment'' action button. To create the decrement button: the user adds a value node \texttt{"-1"} as a child and programs the step to the ``Decrement'' button.

Since \texttt{sum} is variadic, each button click appends another argument to the same formula. After several clicks the formula looks like \texttt{sum(1, -1, 1, 1, 1, -1)} and evaluates to the running total.

\subsubsection{Todo List}

Demonstrates recording a multi-step ``add item'' pattern. The document contains a \texttt{ul} with existing \texttt{li} items, a text input for the new item name, and an ``Add'' action button targeting the list.

To create the button: the user selects the \texttt{ul}, adds a new empty \texttt{li}, then copies the input value into the new item's text. The user records both steps and programs them to the ``Add'' action button. Each button click replays the pattern, appending a new item with the current input text. Finished todo items can be removed by selecting and deleting them.

\subsubsection{Price Calculator (Formulas)}

Demonstrates reactive computation. The document contains value nodes for quantity (\texttt{"3"}) and price (\texttt{"25"}), plus a \texttt{formula(product)} node referencing both. The formula evaluates to \texttt{"75"} and updates automatically when either value changes.

Additional formulas like \texttt{countChildren} can count items in a list dynamically.


\section{Platform and technologies}

The project uses the following technologies:

\begin{itemize}
\item \textbf{Programming Languages:}
\begin{itemize}
\setlength{\itemsep}{-5pt}
\item TypeScript -- all packages and applications
\end{itemize}

\item \textbf{Frameworks and Libraries:}
\begin{itemize}
\setlength{\itemsep}{-5pt}
\item React 19 -- user interface framework
\item Fluent UI (\texttt{@fluentui/react-components}) -- UI component library
\item Loro -- CRDT library with native movable tree support
\item Vite -- build tool and development server
\end{itemize}

\item \textbf{Testing:}
\begin{itemize}
\setlength{\itemsep}{-5pt}
\item Vitest -- unit testing for core library
\item Playwright -- end-to-end testing for web application
\end{itemize}

\item \textbf{Code Quality:}
\begin{itemize}
\setlength{\itemsep}{-5pt}
\item ESLint -- linting with typescript-eslint
\item eslint-plugin-simple-import-sort -- import sorting
\item eslint-plugin-unused-imports -- unused import removal
\end{itemize}

\item \textbf{Infrastructure:}
\begin{itemize}
\setlength{\itemsep}{-5pt}
\item npm workspaces -- monorepo management
\item GitHub Pages -- web application hosting
\item Azure App Service -- sync server hosting
\item WebSocket -- real-time synchronization
\end{itemize}
\end{itemize}


\section{Evaluation}

The evaluation approach focuses on demonstrating that the CRDT-based synchronization correctly implements the Denicek editing model and supports the formative examples from the original paper.

\textbf{Unit Tests} The core library includes unit tests (Vitest) that verify:
\begin{itemize}
\setlength{\itemsep}{-5pt}
\item Correctness of node operations (add, delete, move, copy)
\item Conflict resolution behavior for concurrent operations
\item Undo/redo functionality
\item Recording and replay of operation sequences
\item Synchronization between multiple documents
\end{itemize}

\textbf{End-to-End Tests} The web application includes Playwright tests that verify:
\begin{itemize}
\setlength{\itemsep}{-5pt}
\item User interface interactions (selection, navigation, editing)
\item Recording and replay workflows
\item Undo/redo through the UI
\end{itemize}

\textbf{Formative Examples} Evaluation against examples from the Denicek paper (Section 2.7): counter (reactive values, action buttons), todo list (recording patterns), price calculator (formula engine).

\textbf{Comparison with Original Denicek} A qualitative comparison will assess:
\begin{itemize}
\setlength{\itemsep}{-5pt}
\item Feature parity with the original system
\item Differences in conflict resolution behavior
\item Developer ergonomics of the API
\end{itemize}


\section{Risks}

\textbf{CRDT Limitations} Some Denicek operations may not map cleanly to CRDT semantics. Mitigation: Identify problematic operations early and design workarounds or document limitations.

\textbf{Loro Performance} Large documents may cause performance issues. Mitigation: Implement lazy loading and pagination if needed; profile performance with realistic document sizes.

\textbf{Conflict Resolution Semantics} Users may expect different conflict resolution behavior than what CRDTs provide. Mitigation: Document the conflict resolution rules clearly; provide UI feedback when conflicts are resolved.

\textbf{Browser Compatibility} WebAssembly (used by Loro) may have compatibility issues in some browsers. Mitigation: Test on all target browsers; provide fallback or polyfills if needed.

\textbf{Scope Creep} The desire to implement all Denicek features may exceed available time. Mitigation: Prioritize core functionality (editing, sync, undo/redo) over advanced features (formula evaluation, debugging).


\section{Milestones / Deliverables}

\textbf{MyDenicek Library:} TypeScript library with CRDT-based documents (element, value, formula, ref, action nodes), edit operations, formula engine (19 operations), action nodes with recording/replay, Loro-based conflict resolution, and undo/redo.

\textbf{MyWebnicek Application:} React web app with document rendering, toolbar-based editing, recording/replay UI, and WebSocket collaboration.

\textbf{Documentation:} README, API docs, architecture overview, conflict resolution rules.

\textbf{Tests:} Unit tests (Vitest) for core library; E2E tests (Playwright) for web app.

\textbf{Demo:} Live demonstration of editing, recording/replay, collaboration, and conflict resolution.

\textbf{Source Code:} Open-source GitHub repository.


\section{Time Schedule}

The project spans September 2025 to March 2026. The proposal was submitted on 16.10.2025 and approved on 11.11.2025. Work began with attendance at the DARE2025 summer school on CRDTs and local-first software, followed by analysis of the original Denicek system and prototyping. The following table shows completed work (DARE2025 + git history, counting each day with commits as 1 full working day) and estimated remaining effort.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|r|l|}
\hline
\textbf{Milestone} & \textbf{Activity} & \textbf{Time} & \textbf{MD} & \textbf{Status} \\
\hline
DARE2025 & Summer school on CRDTs and local-first & Sep 2025 & 5 & Done \\
\hline
Analysis & Study Denicek, CRDTs, prototype & Oct--Nov 2025 & 4 & Done \\
\hline
Core + Undo & DenicekModel, UndoManager, basic UI & Nov--Dec 2025 & 14 & Done \\
\hline
Recording/Replay & Recorder, generalized patches & Dec 2025 & 1 & Done \\
\hline
Monorepo + Tests & Package structure, unit/E2E tests & Jan 2026 & 6 & Done \\
\hline
Loro Migration & Replace Automerge with Loro CRDT & Jan 2026 & 4 & Done \\
\hline
Programmable Buttons & Action nodes, recording to buttons & Jan 2026 & 2 & Done \\
\hline
Formula Engine & Evaluation, operations, ref nodes & Jan 2026 & 2 & Done \\
\hline
Sync Server Deployment & Deploy to Azure, public collaboration & Jan 2026 & 4 & Done \\
\hline
\hline
\multicolumn{3}{|l|}{\textbf{Completed}} & \textbf{42} & \\
\hline
\hline
Web Application Polish & UI improvements, conflict feedback & Feb 2026 & 6 & Planned \\
\hline
Formative Examples & Counter, todo list, price calculator demos & Feb--Mar 2026 & 5 & Planned \\
\hline
Testing \& Bug Fixes & E2E tests, edge cases, bug fixes & Mar 2026 & 5 & Planned \\
\hline
Documentation & README, API docs, video demo & Mar 2026 & 4 & Planned \\
\hline
Finalization & Polish, presentation preparation & Mar 2026 & 3 & Planned \\
\hline
\hline
\multicolumn{3}{|l|}{\textbf{Remaining (estimated)}} & \textbf{23} & \\
\hline
\hline
\multicolumn{3}{|l|}{\textbf{Total}} & \textbf{65} & \\
\hline
\end{tabular}
\caption{Project timeline: completed work (DARE2025 summer school + git history) and estimated remaining effort.}
\end{table}

The completed work includes migration from Automerge to Loro CRDT (January 2026), formula engine, programmable buttons, and sync server deployment. Online collaboration is now functional (see NFR-10 for deployment URLs). Remaining work focuses on UI polish and formative example demonstrations.


\section{Form of collaboration}

Collaboration with the supervisor, Mgr. Tomáš Petříček, Ph.D., is essential for ensuring alignment with the original Denicek design and research objectives.

\subsection{Consulting plan}

\textbf{Regular Meetings} Weekly meetings with the supervisor, 60--90 minutes each. Topics: progress updates, technical challenges, design decisions, alignment with original Denicek semantics.

\textbf{Ad-hoc Communication} Discord for quick questions between meetings.

\textbf{Code Reviews} The supervisor may review code and provide feedback on architecture and implementation decisions.

\subsection{Repository management}

The project is hosted on GitHub at \url{https://github.com/krsion/MyDenicek}. Development follows standard Git workflow with feature branches and pull requests. The main branch is deployed to GitHub Pages for the live demo.


\bibliographystyle{plain}
\begin{thebibliography}{9}
\bibitem{denicek2024}
T. Petříček, et al. \textit{Denicek: Computational Substrate for Document-Oriented End-User Programming.} In Proceedings of the 38th Annual ACM Symposium on User Interface Software and Technology (UIST '25). no. 32, pp. 1--19.

\bibitem{klep2019}
M. Kleppmann, et al. Local-first software: you own your data, in spite of the cloud. Proceedings of the 2019 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software. 2019.

\bibitem{klokmose2024}
Clemens Nylandsted Klokmose, James R. Eagan, and Peter van Hardenberg. 2024. MyWebstrates: Webstrates as Local-first Software. In Proceedings of the 37th Annual ACM Symposium on User Interface Software and Technology (UIST '24). Association for Computing Machinery, New York, NY, USA, Article 42, 1–12.

\bibitem{loro}
Loro: Reimagine state management with CRDTs. \url{https://loro.dev/}

\bibitem{crdtoverview}
N. Preguiça. \textit{Conflict-free Replicated Data Types: An Overview.} 2018. \url{https://arxiv.org/abs/1806.10254}.

\end{thebibliography}

\end{document}
